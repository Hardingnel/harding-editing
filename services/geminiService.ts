import { GoogleGenAI, Type, GenerateContentResponse } from "@google/genai";

// Initialize the API client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// The specific model for "nano banana" / Gemini 2.5 Flash Image
const MODEL_NAME = 'gemini-2.5-flash-image';
// Model for analysis (VQA)
const ANALYSIS_MODEL_NAME = 'gemini-2.5-flash';

export interface GeneratedImageResult {
  imageUrl: string;
  text?: string;
}

export interface EnhancementValues {
  brightness: number;
  contrast: number;
  saturation: number;
}

/**
 * Helper to parse the response from Gemini and extract the image.
 */
const parseGeminiResponse = (response: GenerateContentResponse): GeneratedImageResult => {
  let result: GeneratedImageResult = { imageUrl: '' };

  if (response.candidates && response.candidates.length > 0) {
    const content = response.candidates[0].content;
    if (content && content.parts) {
      for (const part of content.parts) {
        if (part.inlineData) {
          const base64EncodeString = part.inlineData.data;
          // The API returns raw base64, we need to prefix it for the browser
          result.imageUrl = `data:image/png;base64,${base64EncodeString}`;
        } else if (part.text) {
          result.text = part.text;
        }
      }
    }
  }

  if (!result.imageUrl) {
    throw new Error("No image was generated by the model.");
  }

  return result;
};

/**
 * Edits an image based on a text prompt using Gemini 2.5 Flash Image.
 * Supports optional style reference image for style transfer.
 */
export const editImageWithGemini = async (
  base64Image: string,
  mimeType: string,
  prompt: string,
  styleReference?: { base64: string; mimeType: string }
): Promise<GeneratedImageResult> => {
  try {
    // Ensure clean base64 string, handling any data URI scheme (including unknown types for RAW)
    const cleanBase64 = base64Image.replace(/^data:.*?;base64,/, '');
    
    const parts: any[] = [
      {
        inlineData: {
          data: cleanBase64,
          mimeType: mimeType,
        },
      }
    ];

    // If a style reference image is provided, add it as the second part
    if (styleReference) {
      const cleanStyleBase64 = styleReference.base64.replace(/^data:.*?;base64,/, '');
      parts.push({
        inlineData: {
          data: cleanStyleBase64,
          mimeType: styleReference.mimeType,
        }
      });
    }

    // Add the text prompt last
    parts.push({ text: prompt });

    const response = await ai.models.generateContent({
      model: MODEL_NAME,
      contents: {
        parts: parts,
      },
    });

    return parseGeminiResponse(response);
  } catch (error) {
    console.error("Error editing image:", error);
    throw error;
  }
};

/**
 * Generates a new image from scratch based on a text prompt.
 */
export const generateImage = async (prompt: string): Promise<GeneratedImageResult> => {
  try {
    const response = await ai.models.generateContent({
      model: MODEL_NAME,
      contents: {
        parts: [
          {
            text: prompt,
          },
        ],
      },
    });

    return parseGeminiResponse(response);
  } catch (error) {
    console.error("Error generating image:", error);
    throw error;
  }
};

/**
 * Analyzes the image and returns optimal values for brightness, contrast, and saturation.
 */
export const getAutoEnhancementValues = async (
  base64Image: string,
  mimeType: string
): Promise<EnhancementValues> => {
  try {
    // Ensure clean base64 string
    const cleanBase64 = base64Image.replace(/^data:.*?;base64,/, '');

    const response = await ai.models.generateContent({
      model: ANALYSIS_MODEL_NAME,
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: mimeType,
            },
          },
          {
            text: "Analyze this image. I have image editing sliders for Brightness, Contrast, and Saturation. The scale is 0 to 200, where 100 is neutral (no change). Suggest optimal integer values to improve the image aesthetics (e.g. fix exposure, enhance colors). Return JSON.",
          },
        ],
      },
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            brightness: { type: Type.INTEGER },
            contrast: { type: Type.INTEGER },
            saturation: { type: Type.INTEGER },
          },
        },
      },
    });

    if (response.text) {
      return JSON.parse(response.text) as EnhancementValues;
    }
    
    // Fallback if no text returned
    return { brightness: 100, contrast: 100, saturation: 100 };
  } catch (error) {
    console.error("Error analyzing image for auto-enhance:", error);
    // Return safe defaults on error
    return { brightness: 100, contrast: 100, saturation: 100 };
  }
};